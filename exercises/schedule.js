// ‚úÖ URL Google Sheet
const SCHEDULE_URL = "https://docs.google.com/spreadsheets/d/1xdGIaXekYFQqm1K6ZZyX5pcrmrmjFdSgTJeW27yZJmQ/gviz/tq?tqx=out:json";
const VOCAB_URL = "https://docs.google.com/spreadsheets/d/1KaYYyvkjFxVVobRHNs9tDxW7S79-c5Q4mWEKch6oqks/gviz/tq?tqx=out:json";


// ‚úÖ Bi·∫øn to√†n c·ª•c
let wordBank = [];
let suggestedUnitRaw = "";
let normalizedUnitCode = "";

const spacedConfig = {
  "2": [4, 11, 25],
  "3": [4, 11, 25],
  "4": [4, 11, 25],
  "5": [4, 11, 25],
  "6": [4, 11, 25]
};

// ‚úÖ Chu·∫©n h√≥a m√£ b√†i
function normalizeUnit(str) {
  if (!str || typeof str !== "string") return "";
  return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^0-9]/g, "").trim();
}

function extractCodeFromTitle(title) {
  if (!title || typeof title !== "string") return "";

  // T√°ch theo d·∫•u c√°ch ho·∫∑c d·∫•u g·∫°ch
  const parts = title.trim().split(/[-\s.]+/);

  // Ki·ªÉm tra ƒë√∫ng ƒë·ªãnh d·∫°ng: 1 s·ªë - 2 s·ªë - 1 s·ªë
  if (parts.length >= 3 && /^\d+$/.test(parts[0]) && /^\d+$/.test(parts[1]) && /^\d+$/.test(parts[2])) {
    return parts[0] + parts[1] + parts[2]; // V√≠ d·ª•: "4" + "04" + "1" ‚Üí "4041"
  }

  return ""; // Kh√¥ng kh·ªõp ƒë·ªãnh d·∫°ng
}


async function resolveTitlesFromSheet2(codeList) {
  const res = await fetch(VOCAB_URL);
  const text = await res.text();
  const json = JSON.parse(text.substring(47).slice(0, -2));
  const rows = json.table.rows;

  const titleMap = {};

  for (let row of rows) {
    const rawTitle = row.c[1]?.v?.toString().trim(); // c·ªôt B: ti√™u ƒë·ªÅ b√†i h·ªçc
    if (!rawTitle) continue;

    const code = extractCodeFromTitle(rawTitle); // ‚úÖ t√°ch ƒë√∫ng m√£ b√†i t·ª´ ti√™u ƒë·ªÅ
    if (codeList.includes(code)) {
      titleMap[code] = rawTitle; // ‚úÖ gi·ªØ nguy√™n ti√™u ƒë·ªÅ g·ªëc
    }
  }

  return titleMap;
}



// ‚úÖ Chuy·ªÉn ng√†y d·∫°ng "dd/mm/yyyy" ‚Üí "yyyy-mm-dd"
function convertSheetDateToISO(dateStr) {
  if (!dateStr || typeof dateStr !== "string") return "";
  const parts = dateStr.split("/").map(p => p.trim());
  if (parts.length !== 3) return "";

  let [dd, mm, yyyy] = parts;
  if (dd.length === 1) dd = "0" + dd;
  if (mm.length === 1) mm = "0" + mm;

  const isoStr = `${yyyy}-${mm}-${dd}`;
  const testDate = new Date(isoStr);
  if (isNaN(testDate.getTime())) {
    console.warn("‚ö†Ô∏è Ng√†y kh√¥ng h·ª£p l·ªá:", dateStr);
    return "";
  }

  return isoStr;
}

// ‚úÖ T·∫°o l·ªãch h·ªçc t·ª´ ng√†y g·ªëc
function generateLessonSchedule(mainCode, relatedCodes, baseDateStr, reviewOffsets) {
  const baseDate = new Date(baseDateStr);
  const schedule = [];
  const usedDates = new Map(); // date ‚Üí s·ªë l∆∞·ª£ng b√†i ƒë√£ g√°n
  const newLessonDates = new Set(); // ‚úÖ ng√†y ƒë√£ c√≥ b√†i m·ªõi

  // ‚úÖ G√°n b√†i m·ªõi v√†o ng√†y g·ªëc ‚Äî lu√¥n ƒë·ª©ng m·ªôt m√¨nh
  const baseISO = baseDate.toISOString().split("T")[0];
  schedule.push({ date: baseISO, code: mainCode, type: "new", relatedTo: mainCode });
  usedDates.set(baseISO, 1);
  newLessonDates.add(baseISO); // ‚úÖ ƒë√°nh d·∫•u ng√†y c√≥ b√†i m·ªõi

  // ‚úÖ G√°n b√†i √¥n t·∫≠p v√†o c√°c ng√†y offset
  for (let offset of reviewOffsets) {
    const d = new Date(baseDate);
    d.setDate(d.getDate() + offset);
    let iso = d.toISOString().split("T")[0];

    // ‚úÖ N·∫øu ng√†y c√≥ b√†i m·ªõi ho·∫∑c ƒë√£ ƒë·ªß 2 b√†i ‚Üí l√πi
    while (newLessonDates.has(iso) || (usedDates.get(iso) || 0) >= 2) {
      d.setDate(d.getDate() + 1);
      iso = d.toISOString().split("T")[0];
    }

    schedule.push({ date: iso, code: mainCode, type: "review", relatedTo: mainCode });
    usedDates.set(iso, (usedDates.get(iso) || 0) + 1);
  }

  // ‚úÖ G√°n b√†i li√™n quan v√†o c√°c ng√†y ti·∫øp theo
  let relatedIndex = 0;
  let nextDate = new Date(baseDate);
  while (relatedIndex < relatedCodes.length) {
    nextDate.setDate(nextDate.getDate() + 1);
    let iso = nextDate.toISOString().split("T")[0];

    // ‚úÖ N·∫øu ng√†y c√≥ b√†i m·ªõi ho·∫∑c ƒë√£ ƒë·ªß 2 b√†i ‚Üí l√πi
    while (newLessonDates.has(iso) || (usedDates.get(iso) || 0) >= 2) {
      nextDate.setDate(nextDate.getDate() + 1);
      iso = nextDate.toISOString().split("T")[0];
    }

    schedule.push({ date: iso, code: relatedCodes[relatedIndex], type: "related", relatedTo: mainCode });
    usedDates.set(iso, (usedDates.get(iso) || 0) + 1);
    relatedIndex++;
  }

  console.log(`üìÖ L·ªãch h·ªçc t·∫°o t·ª´ ng√†y ${baseDateStr} cho b√†i ${mainCode}:`, schedule);
  return schedule;
}

function buildFullScheduleFromLessons(lessonList, reviewOffsets) {
  const schedule = {};
  const usedDates = new Map(); // date ‚Üí s·ªë l∆∞·ª£ng b√†i ƒë√£ g√°n
  const newLessonDates = [];   // danh s√°ch b√†i m·ªõi ƒë√£ g√°n

  // ‚úÖ B∆∞·ªõc 1: G√°n b√†i m·ªõi v√†o ng√†y g·ªëc
  for (let lesson of lessonList) {
    const iso = lesson.baseDate;
    if (!iso) continue;

    if (!schedule[iso]) schedule[iso] = [];
    schedule[iso].push({
      code: lesson.code,
      title: lesson.title,
      type: "new",
      relatedTo: lesson.code
    });

    usedDates.set(iso, (usedDates.get(iso) || 0) + 1);
    newLessonDates.push({ code: lesson.code, date: iso });
  }

  // ‚úÖ B∆∞·ªõc 2: G√°n b√†i √¥n t·∫≠p theo offset t·ª´ ng√†y g·ªëc
  for (let item of newLessonDates) {
    for (let offset of reviewOffsets) {
      const d = new Date(item.date);
      d.setDate(d.getDate() + offset);
      let iso = d.toISOString().split("T")[0];

      // ‚úÖ N·∫øu ng√†y c√≥ b√†i m·ªõi ho·∫∑c ƒë·ªß 2 b√†i ‚Üí l√πi
      while ((schedule[iso]?.some(e => e.type === "new")) || (usedDates.get(iso) || 0) >= 2) {
        d.setDate(d.getDate() + 1);
        iso = d.toISOString().split("T")[0];
      }

      if (!schedule[iso]) schedule[iso] = [];
      schedule[iso].push({
        code: item.code,
        title: item.code,
        type: "review",
        relatedTo: item.code
      });

      usedDates.set(iso, (usedDates.get(iso) || 0) + 1);
    }
  }

  // ‚úÖ B∆∞·ªõc 3: G√°n b√†i li√™n quan sau b√†i m·ªõi
  for (let lesson of lessonList) {
    let d = new Date(lesson.baseDate);
    d.setDate(d.getDate() + 1); // b·∫Øt ƒë·∫ßu t·ª´ ng√†y sau b√†i m·ªõi

    for (let relatedCode of lesson.relatedCodes || []) {
      let iso = d.toISOString().split("T")[0];

      // ‚úÖ N·∫øu ng√†y c√≥ b√†i m·ªõi ho·∫∑c ƒë·ªß 2 b√†i ‚Üí l√πi
      while ((schedule[iso]?.some(e => e.type === "new")) || (usedDates.get(iso) || 0) >= 2) {
        d.setDate(d.getDate() + 1);
        iso = d.toISOString().split("T")[0];
      }

      if (!schedule[iso]) schedule[iso] = [];
      schedule[iso].push({
        code: relatedCode,
        title: relatedCode,
        type: "related",
        relatedTo: lesson.code
      });

      usedDates.set(iso, (usedDates.get(iso) || 0) + 1);
      d.setDate(d.getDate() + 1); // ti·∫øp t·ª•c ng√†y sau
    }
  }

  console.log("üìÖ L·ªãch h·ªçc ƒë√£ x√¢y d·ª±ng:", schedule);
  return schedule;
}



// ‚úÖ T·∫°o l·∫°i to√†n b·ªô l·ªãch h·ªçc t·ª´ Sheet theo l·ªõp
async function generateFullScheduleFromSheet(className) {
  try {
    const res = await fetch(SCHEDULE_URL);
    const text = await res.text();
    const json = JSON.parse(text.substring(47).slice(0, -2));
    const rows = json.table.rows;

    const lessonList = [];

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!row || !row.c || !row.c[0] || !row.c[1] || !row.c[2]) {
        console.warn(`‚ö†Ô∏è B·ªè qua d√≤ng ${i + 1} v√¨ thi·∫øu d·ªØ li·ªáu`);
        continue;
      }

      const sheetClass = row.c[0].v.toString().trim().toLowerCase();
      if (!sheetClass.includes(className)) {
        console.warn(`‚ö†Ô∏è B·ªè qua d√≤ng ${i + 1} v√¨ l·ªõp kh√¥ng kh·ªõp: l·ªõp trong Sheet = ${sheetClass}, l·ªõp ƒë√£ ch·ªçn = ${className}`);
        continue;
      }

      const mainRaw = row.c[2].v.toString().trim();
      const relatedRaw = row.c[3]?.v?.toString().trim() || "";

      const mainCode = normalizeUnit(mainRaw);
      const relatedCodes = relatedRaw
        ? relatedRaw.split(",").map(code => normalizeUnit(code.trim())).filter(Boolean)
        : [];

      const rawDate = row.c[1].v.toString().trim();
      const baseDate = convertSheetDateToISO(rawDate);

      lessonList.push({
        code: mainCode,
        title: mainRaw,
        relatedCodes,
        baseDate // ‚úÖ d√πng ng√†y g·ªëc t·ª´ Sheet
      });


    }

    const reviewOffsets = spacedConfig[className] || [4, 11, 25];
    const fullSchedule = buildFullScheduleFromLessons(lessonList, reviewOffsets);

    const docRef = window.doc(window.db, "lich", className);
    await window.setDoc(docRef, fullSchedule);
    console.log("‚úÖ ƒê√£ ghi to√†n b·ªô l·ªãch m·ªõi v√†o Firebase cho l·ªõp:", className);

    await autoFillOldLessons(className, fullSchedule);
    renderFullScheduleFromFirebase(className);
    showTodayLessonFromFirebase(className);
  } catch (err) {
    console.error("‚ùå L·ªói khi t·∫°o l·∫°i l·ªãch h·ªçc:", err.message);
  }
}


async function autoFillOldLessons(className, currentSchedule) {
  console.log("üìå B·∫Øt ƒë·∫ßu b·ªï sung b√†i c≈© cho l·ªõp:", className);

  const todayISO = new Date().toISOString().split("T")[0];
  const bosungRef = window.doc(window.db, "bosung", className);

  // ‚úÖ L·∫•y d·ªØ li·ªáu b·ªï sung c≈© t·ª´ Firebase
  const bosungSnap = await window.getDoc(bosungRef);
  const oldBosung = bosungSnap.exists() ? bosungSnap.data() : {};

  // ‚úÖ Gi·ªØ l·∫°i c√°c ng√†y tr∆∞·ªõc h√¥m nay
  const preserved = {};
  for (let date in oldBosung) {
    if (date < todayISO) {
      preserved[date] = oldBosung[date];
    }
  }

  // ‚úÖ Lo·∫°i tr·ª´ t·∫•t c·∫£ m√£ b√†i ƒë√£ c√≥ trong l·ªãch
  const usedCodes = Object.values(currentSchedule).flat().map(item => normalizeUnit(item.code));

  // ‚úÖ Lo·∫°i tr·ª´ th√™m c√°c b√†i b·ªï sung tr∆∞·ªõc h√¥m nay
  const preservedCodes = Object.values(preserved).flat().map(item => normalizeUnit(item.code));

  // ‚úÖ T√¨m b√†i c≈© t·ª´ Sheet 2
  const res = await fetch(VOCAB_URL);
  const text = await res.text();
  const json = JSON.parse(text.substring(47).slice(0, -2));
  const rows = json.table.rows;

  const allUnits = rows.map(row => {
    const raw = row.c[1]?.v?.toString().trim();
    return extractCodeFromTitle(raw);
  }).filter(Boolean);

  const newCodes = Object.values(currentSchedule).flat()
    .filter(item => item.type === "new")
    .map(item => normalizeUnit(item.code));

  const highestCode = newCodes.sort().reverse()[0];
  const sortedOldUnits = allUnits
    .filter(code => code < highestCode)
    .sort((a, b) => {
      const [la, lb] = [parseInt(a[0]), parseInt(b[0])];
      return lb - la || b.localeCompare(a);
    });

  

  


  // ‚úÖ T√¨m c√°c ng√†y tr·ªëng t·ª´ h√¥m nay tr·ªü ƒëi
  const allDates = Object.keys(currentSchedule).sort((a, b) => new Date(a) - new Date(b));
  const maxDate = new Date(allDates[allDates.length - 1]);

  const emptyDates = [];
  const d = new Date(todayISO);
  while (d <= maxDate) {
    const iso = d.toISOString().split("T")[0];
    if (!currentSchedule[iso]) emptyDates.push(iso);
    d.setDate(d.getDate() + 1);
  }

  console.log("üìÖ Ng√†y tr·ªëng c·∫ßn b·ªï sung:", emptyDates);

  // ‚úÖ Lo·∫°i tr·ª´ b√†i ƒë√£ h·ªçc v√† b√†i t·ª´ng b·ªï sung tr∆∞·ªõc h√¥m nay
  let excluded = new Set([...usedCodes, ...preservedCodes]);
  let finalUnits = [...new Set(sortedOldUnits.filter(code => !excluded.has(code)))];

  // ‚úÖ N·∫øu kh√¥ng ƒë·ªß b√†i ƒë·ªÉ g√°n ‚Üí cho ph√©p d√πng l·∫°i b√†i ƒë√£ t·ª´ng b·ªï sung
  const totalNeeded = emptyDates.length * 2;
  if (finalUnits.length < totalNeeded) {
    console.warn("‚ö†Ô∏è Kh√¥ng ƒë·ªß b√†i m·ªõi ƒë·ªÉ b·ªï sung, cho ph√©p d√πng l·∫°i b√†i ƒë√£ t·ª´ng b·ªï sung tr∆∞·ªõc h√¥m nay");
    excluded = new Set(usedCodes); // b·ªè preservedCodes ra kh·ªèi excluded
    finalUnits = [...new Set(sortedOldUnits.filter(code => !excluded.has(code)))];
  }

  // ‚úÖ Log ki·ªÉm tra
  console.log("üîç T·ªïng s·ªë b√†i c≈© c√≥ th·ªÉ d√πng:", sortedOldUnits.length);
  console.log("üîç S·ªë b√†i ƒë√£ h·ªçc:", usedCodes.length);
  console.log("üîç S·ªë b√†i ƒë√£ t·ª´ng b·ªï sung:", preservedCodes.length);
  console.log("üîç T·ªïng s·ªë b√†i b·ªã lo·∫°i:", excluded.size);
  console.log("üîç B√†i c√≤n l·∫°i ƒë·ªÉ b·ªï sung:", finalUnits.length);
  console.log("üîç Danh s√°ch b√†i c√≤n l·∫°i:", finalUnits);

  // ‚úÖ Tra title t·ª´ Sheet 2
  const titleMap = {};
  for (let row of rows) {
    const rawTitle = row.c[1]?.v?.toString().trim();
    const code = extractCodeFromTitle(rawTitle);
    if (finalUnits.includes(code)) {
      titleMap[code] = rawTitle;
    }


  }

  // ‚úÖ G√°n b√†i b·ªï sung v√†o l·ªãch v√† bosung m·ªõi ‚Äî m·ªói ng√†y 1 b√†i kh√°c nhau
  const bosungSchedule = {};
  let unitIndex = 0;

  for (let date of emptyDates) {
    const entries = [];

    for (let j = 0; j < 2; j++) {
      // ‚úÖ N·∫øu h·∫øt b√†i ‚Üí quay l·∫°i ƒë·∫ßu danh s√°ch
      if (unitIndex >= finalUnits.length) unitIndex = 0;

      const code = finalUnits[unitIndex];
      const entry = {
        code,
        title: titleMap[code] || code,
        type: "old",
        relatedTo: ""
      };

      entries.push(entry);
      unitIndex++;
    }

    if (entries.length > 0) {
      currentSchedule[date] = entries;
      bosungSchedule[date] = entries;
      console.log(`üìÖ G√°n ${entries.length} b√†i v√†o ng√†y ${date}:`, entries.map(e => e.code).join(", "));
    }
  }



  // ‚úÖ Ghi l·ªãch m·ªõi v√†o Firebase
  const docRef = window.doc(window.db, "lich", className);
  await window.setDoc(docRef, currentSchedule);

  // ‚úÖ G·ªôp d·ªØ li·ªáu c≈© + m·ªõi ‚Üí ghi v√†o bosung
  let finalBosung;

  if (finalUnits.length < totalNeeded) {
    console.warn("‚ö†Ô∏è Kh√¥ng ƒë·ªß b√†i ƒë·ªÉ b·ªï sung, cho ph√©p quay v√≤ng l·∫°i t·ª´ ƒë·∫ßu ‚Äî reset bosung");
    finalBosung = bosungSchedule;

    // ‚úÖ TH√äM LOG KI·ªÇM TRA RESET
    console.log("üßπ ƒê√£ RESET bosung ‚Äî ch·ªâ ghi l·∫°i b√†i v·ª´a b·ªï sung:");
    console.table(bosungSchedule);
  } else {
    finalBosung = { ...preserved, ...bosungSchedule };

    // ‚úÖ TH√äM LOG KI·ªÇM TRA G·ªòP
    console.log("üì¶ ƒê√£ G·ªòP bosung ‚Äî gi·ªØ l·∫°i b√†i c≈© v√† th√™m b√†i m·ªõi:");
    console.log("üóÇ preserved:", Object.keys(preserved).length, "ng√†y");
    console.log("üÜï bosung m·ªõi:", Object.keys(bosungSchedule).length, "ng√†y");
  }


  await window.setDoc(bosungRef, finalBosung);


  console.log("‚úÖ ƒê√£ c·∫≠p nh·∫≠t l·ªãch b·ªï sung v√† gi·ªØ l·∫°i d·ªØ li·ªáu c≈© tr∆∞·ªõc h√¥m nay");
}



// ‚úÖ Hi·ªÉn th·ªã b·∫£ng l·ªãch h·ªçc t·ª´ h√¥m nay tr·ªü ƒëi
async function renderFullScheduleFromFirebase(className) {
  const docRef = window.doc(window.db, "lich", className);
  const today = new Date();

  try {
    const snapshot = await window.getDoc(docRef);
    if (!snapshot.exists()) {
      console.warn("üì≠ Kh√¥ng c√≥ l·ªãch h·ªçc n√†o trong Firebase cho l·ªõp", className);
      return;
    }

    const data = snapshot.data();
    const tableBody = document.querySelector("#scheduleTable tbody");
    tableBody.innerHTML = "";

    const entries = Object.entries(data)
    .sort(([a], [b]) => new Date(a) - new Date(b));



    let stt = 1;
    for (let [dateStr, lessons] of entries) {
      const row = document.createElement("tr");

      const titles = lessons.map(l => l.title).join("<br>");
      const labels = lessons.map(l => {
        return l.type === "new"
          ? "B√†i m·ªõi - Ph·∫£i h·ªçc"
          : l.type === "review"
          ? "√în t·∫≠p b√†i m·ªõi - N√™n h·ªçc"
          : l.type === "related"
          ? "B√†i li√™n quan b√†i m·ªõi - N√™n h·ªçc"
          : l.type === "old"
          ? "B√†i c≈©"
          : l.type;
      }).join("<br>");

      const related = lessons.map(l => l.relatedTo || "").join("<br>");

      row.innerHTML = `
        <td>${stt++}</td>
        <td>${dateStr}</td>
        <td>${titles}</td>
        <td>${labels}</td>
        <td>${related}</td>
      `;
      tableBody.appendChild(row);
    }



    console.log("üìã ƒê√£ hi·ªÉn th·ªã l·ªãch h·ªçc t·ª´ h√¥m nay tr·ªü ƒëi cho l·ªõp", className);
  } catch (err) {
    console.error("‚ùå L·ªói khi hi·ªÉn th·ªã b·∫£ng l·ªãch h·ªçc:", err.message);
  }
}

// ‚úÖ Hi·ªÉn th·ªã danh s√°ch b√†i h·ªçc h√¥m nay ƒë·ªÉ ch·ªçn
function renderLessonChecklist(todayLessons) {
  const container = document.getElementById("lessonList");
  container.innerHTML = "";

  const sorted = [...todayLessons].sort((a, b) => {
    const order = { new: 0, related: 1, review: 2 };
    return order[a.type] - order[b.type];
  });

  sorted.forEach(item => {
    const label =
      item.type === "new"
        ? "B√†i m·ªõi"
        : item.type === "related"
        ? `Li√™n quan ƒë·∫øn ${item.relatedTo}`
        : item.type === "old"
        ? "B√†i c≈©"
        : `√în t·∫≠p c·ªßa ${item.relatedTo}`;


    const div = document.createElement("div");
    div.innerHTML = `
      <label>
        <input type="checkbox" value="${normalizeUnit(item.code)}" data-title="${item.title}" />
        ${item.title} (${label})
      </label>
    `;
    container.appendChild(div);
  });

  console.log("üìë ƒê√£ hi·ªÉn th·ªã danh s√°ch b√†i h·ªçc h√¥m nay:", sorted);
  document.getElementById("btnLearnSuggested").disabled = false;
}

// ‚úÖ Hi·ªÉn th·ªã b√†i h·ªçc h√¥m nay t·ª´ Firebase
async function showTodayLessonFromFirebase(className) {
  const todayISO = new Date().toISOString().split("T")[0];
  const docRef = window.doc(window.db, "lich", className);

  try {
    const snapshot = await window.getDoc(docRef);
    if (!snapshot.exists()) return;

    const data = snapshot.data();
    const todayLessons = data[todayISO] || [];
    if (todayLessons.length === 0) {
      console.warn("üì≠ Kh√¥ng c√≥ b√†i h·ªçc n√†o h√¥m nay cho l·ªõp", className);
      return;
    }

    renderLessonChecklist(todayLessons);
  } catch (err) {
    console.error("‚ùå L·ªói khi hi·ªÉn th·ªã b√†i h·ªçc h√¥m nay:", err.message);
  }
}



// ‚úÖ L·∫•y t·ª´ v·ª±ng t·ª´ nhi·ªÅu b√†i
async function fetchVocabularyFromMultipleUnits(unitCodes) {
  try {
    const res = await fetch(VOCAB_URL);
    const text = await res.text();
    const json = JSON.parse(text.substring(47).slice(0, -2));
    const rows = json.table.rows;

    wordBank = [];

    rows.forEach(row => {
      const unitRaw = row.c[1]?.v?.toString().trim();
      const word = row.c[2]?.v?.toString().trim();
      if (unitCodes.includes(normalizeUnit(unitRaw))) {
        wordBank.push(word);
      }
    });

    wordBank = shuffleArray(wordBank);

    if (wordBank.length === 0) {
      alert("Kh√¥ng t√¨m th·∫•y t·ª´ v·ª±ng cho c√°c b√†i ƒë√£ ch·ªçn.");
      return;
    }

    console.log("üì¶ T·ª´ v·ª±ng ƒë√£ l·∫•y:", wordBank);
    localStorage.setItem("wordBank", JSON.stringify(wordBank));
    localStorage.setItem("victoryTotalWords", wordBank.length);
    window.location.href = "exercise.html";
  } catch (err) {
    console.error("‚ùå L·ªói khi l·∫•y t·ª´ v·ª±ng:", err);
  }
}

// ‚úÖ G·∫Øn s·ª± ki·ªán khi trang t·∫£i
document.addEventListener("DOMContentLoaded", () => {
  const classSelect = document.getElementById("classSelect");
  if (classSelect) {
    classSelect.addEventListener("change", () => {
      const className = classSelect.value.trim().toLowerCase();
      if (!className) return;
      console.log("üéØ ƒê√£ ch·ªçn l·ªõp:", className);
      showTodayLessonFromFirebase(className);
      renderFullScheduleFromFirebase(className);
    });
  }

  const btnLearn = document.getElementById("btnLearnSuggested");
  if (btnLearn) {
    btnLearn.addEventListener("click", () => {
      const checked = Array.from(document.querySelectorAll("#lessonList input[type='checkbox']:checked"));
      if (checked.length === 0) {
        alert("B·∫°n ch∆∞a ch·ªçn b√†i n√†o.");
        return;
      }

      const selectedCodes = checked.map(input => input.value);
      const selectedTitles = checked.map(input => input.dataset.title);

      console.log("üéØ ƒê√£ ch·ªçn h·ªçc c√°c b√†i:", selectedTitles);
      fetchVocabularyFromMultipleUnits(selectedCodes);
    });
  }
});
