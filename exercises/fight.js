import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, setDoc, getDoc, updateDoc, deleteDoc, onSnapshot } 
from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";


// Firebase config
const firebaseConfig = {
  apiKey: "AIzaSyCCVdzWiiFvcWiHVJN-x33YKarsjyziS8E",
  authDomain: "pokemon-capture-10d03.firebaseapp.com",
  projectId: "pokemon-capture-10d03",
  storageBucket: "pokemon-capture-10d03.firebasestorage.app",
  messagingSenderId: "1068125543917",
  appId: "1:1068125543917:web:57de4365ee56729ea8dbe4"
};

// Init Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Local identity
const trainerName = localStorage.getItem("trainerName") || "player";
const trainerClass = localStorage.getItem("trainerClass") || "X";
const playerName = `${trainerName}-${trainerClass}`;

// UI
const meName = document.getElementById("meName");
const levelSelect = document.getElementById("levelSelect");
const joinBtn = document.getElementById("joinBtn");
const leaveBtn = document.getElementById("leaveBtn");
const statusDiv = document.getElementById("status");
const gameArea = document.getElementById("gameArea");
const roomIdSpan = document.getElementById("roomId");
const roomLevelSpan = document.getElementById("roomLevel");
const turnIndexSpan = document.getElementById("turnIndex");
const p1Span = document.getElementById("p1");
const p2Span = document.getElementById("p2");
const currentTurnSpan = document.getElementById("currentTurn");
const questionText = document.getElementById("questionText");
const recordBtn = document.getElementById("recordBtn");
const speechResultDiv = document.getElementById("speechResult");

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;
if (SpeechRecognition) {
  recognition = new SpeechRecognition();
  recognition.lang = "en-US";
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
}



// State
let currentLevel = null;
let currentRoomId = null;
let unsubRoom = null;
let turnTimer = null; // h·∫πn gi·ªù cho l∆∞·ª£t

function startTurnTimer() {
  clearTimeout(turnTimer);
  turnTimer = setTimeout(() => {
    autoEndTurn();
  }, 30000); // 30 gi√¢y
}

async function autoEndTurn() {
  if (!currentLevel || !currentRoomId) return;
  const ref = roomDocRef(currentLevel, currentRoomId);
  const snap = await getDoc(ref);
  if (!snap.exists()) return;
  const data = snap.data();

  // Ch·ªâ auto-end n·∫øu v·∫´n l√† l∆∞·ª£t c·ªßa m√¨nh v√† tr·∫≠n ƒëang ch·∫°y
  if (data.currentTurn === playerName && data.started) {
    // D·ª´ng ghi √¢m n·∫øu ƒëang ch·∫°y
    if (recognition) recognition.stop();
    const nextIndex = data.turnIndex + 1;
    const nextTurn = (data.currentTurn === data.player1) ? data.player2 : data.player1;

    await updateDoc(ref, {
      turnIndex: nextIndex,
      currentTurn: nextTurn,
      lastUpdated: Date.now()
    });
  }
}

function stopTurnTimer() {
  clearTimeout(turnTimer);
}


// ====== L·∫•y c√¢u h·ªèi t·ª´ Google Sheet ======
const SHEET_BAI_HOC = "https://docs.google.com/spreadsheets/d/1xdGIaXekYFQqm1K6ZZyX5pcrmrmjFdSgTJeW27yZJmQ/gviz/tq?tqx=out:json";
const SHEET_TU_VUNG = "https://docs.google.com/spreadsheets/d/1KaYYyvkjFxVVobRHNs9tDxW7S79-c5Q4mWEKch6oqks/gviz/tq?tqx=out:json";

async function getMaxLessonCode() {
  const res = await fetch(SHEET_BAI_HOC);
  const text = await res.text();
  const json = JSON.parse(text.substring(47).slice(0, -2));
  const rows = json.table.rows;

  const baiList = rows
    .map(r => {
      const lop = r.c[0]?.v?.toString().trim();
      const bai = r.c[2]?.v?.toString().trim();
      return lop === trainerClass && bai ? parseInt(bai) : null;
    })
    .filter(v => typeof v === "number");

  if (baiList.length === 0) return null;
  return Math.max(...baiList);
}

async function getQuestionsFromSheet() {
  const maxLessonCode = await getMaxLessonCode();
  if (!maxLessonCode) {
    console.warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y b√†i h·ªçc h·ª£p l·ªá");
    return { p1: [], p2: [] };
  }

  const res = await fetch(SHEET_TU_VUNG);
  const text = await res.text();
  const json = JSON.parse(text.substring(47).slice(0, -2));
  const rows = json.table.rows.slice(1);

  const baiTuVung = {};
  rows.forEach(r => {
    const rawCode = r.c[1]?.v?.toString().trim();
    const meaning = r.c[24]?.v?.toString().trim();
    const questionJ = r.c[9]?.v?.toString().trim();  // C·ªôt J
    const answerL   = r.c[11]?.v?.toString().trim(); // C·ªôt L

    const normalizedCode = parseInt(rawCode?.replace(/\D/g, ""));
    if (!normalizedCode || normalizedCode > maxLessonCode || !meaning) return;

    if (!baiTuVung[normalizedCode]) baiTuVung[normalizedCode] = [];
    baiTuVung[normalizedCode].push({ meaning, questionJ, answerL });
  });

  const allCodes = Object.keys(baiTuVung).map(c => parseInt(c)).sort(() => Math.random() - 0.5);

  const usedMeanings = new Set();
  const quizItemsP1 = [];
  const quizItemsP2 = [];

  allCodes.forEach(code => {
    const words = baiTuVung[code];
    if (!words || words.length === 0) return;

    const candidates = words.filter(w => !usedMeanings.has(w.meaning));
    if (candidates.length === 0) return;

    const item = candidates[Math.floor(Math.random() * candidates.length)];
    usedMeanings.add(item.meaning);

    if (item.questionJ && quizItemsP1.length < 10) quizItemsP1.push(item.questionJ);
    if (item.answerL && quizItemsP2.length < 10) quizItemsP2.push(item.answerL);

    if (quizItemsP1.length >= 10 && quizItemsP2.length >= 10) return;
  });

  return { p1: quizItemsP1, p2: quizItemsP2 };
}

// G·ªçi h√†m n√†y khi b·∫Øt ƒë·∫ßu tr·∫≠n ƒë·ªÉ l·∫•y c√¢u h·ªèi cho t·ª´ng ng∆∞·ªùi
let questionsP1 = [];
let questionsP2 = [];

(async () => {
  const { p1, p2 } = await getQuestionsFromSheet();
  questionsP1 = p1;
  questionsP2 = p2;

  // Log ra ƒë·ªÉ ki·ªÉm tra
  console.log("üìã Danh s√°ch c√¢u h·ªèi cho Player 1:", questionsP1);
  console.log("üìã Danh s√°ch c√¢u h·ªèi cho Player 2:", questionsP2);
})();



// Init UI
meName.textContent = playerName;

// Helpers
function roomDocRef(level, roomId) {
  // Collection per level: "2", "3", "4", "5", "6"; docs: "room-1"..."room-30"
  return doc(db, String(level), roomId);
}

async function ensureRoomExists(level, roomId) {
  const ref = roomDocRef(level, roomId);
  const snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(ref, {
      player1: null,
      player2: null,
      currentTurn: null,
      turnIndex: 0,
      started: false,
      lastUpdated: Date.now()
    });
  }
  return ref;
}

function checkAccuracy(userText, referenceText) {
  const cleanRef = referenceText.toLowerCase().replace(/[^a-z0-9'\s]/g, "");
  const user = userText.toLowerCase().replace(/[^a-z0-9'\s]/g, "");
  const refWords = cleanRef.split(/\s+/);
  const userWords = user.split(/\s+/);

  let correct = 0;
  for (let word of refWords) {
    if (userWords.includes(word)) correct++;
  }

  const percent = Math.round((correct / refWords.length) * 100);
  speechResultDiv.innerHTML =
    `‚úÖ B·∫°n n√≥i: "<i>${userText}</i>"<br>üéØ ƒê√∫ng ${correct}/${refWords.length} t·ª´ ‚Üí <b>${percent}%</b>`;

  // Sau khi ch·∫•m xong ‚Üí t·ª± ƒë·ªông ho√†n th√†nh l∆∞·ª£t
  completeTurn();
}


function renderRoom(data) {
  // Names
  p1Span.textContent = data.player1 || "‚Äî";
  p2Span.textContent = data.player2 || "‚Äî";

  // Color badges by turn
  const isP1Turn = data.currentTurn && data.player1 && data.currentTurn === data.player1;
  const isP2Turn = data.currentTurn && data.player2 && data.currentTurn === data.player2;

  p1Span.className = "badge " + (isP1Turn ? "red" : (data.player1 ? "green" : ""));
  p2Span.className = "badge " + (isP2Turn ? "red" : (data.player2 ? "green" : ""));

  currentTurnSpan.textContent = data.currentTurn || "‚Äî";

  // CH·ªà khai b√°o 1 l·∫ßn ·ªü ƒë√¢y
  const myQuestions = (playerName === data.player1) ? questionsP1 : questionsP2;

  turnIndexSpan.textContent = Math.min(data.turnIndex, myQuestions.length);

  // Question
  questionText.textContent = data.started ? (myQuestions[data.turnIndex] || "H·∫øt c√¢u h·ªèi!") : "Ch∆∞a b·∫Øt ƒë·∫ßu.";



  // Buttons
  const myTurn = data.currentTurn === playerName && data.started;
  recordBtn.disabled = !myTurn || data.turnIndex >= myQuestions.length;

  if (myTurn) {
    startTurnTimer();
  } else {
    stopTurnTimer();
  }

  if (myTurn) {
    startTurnTimer();

    // ‚¨áÔ∏è Kh·ªüi t·∫°o recognition m·ªói l∆∞·ª£t (gi·ªëng speaking.js)
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert("Thi·∫øt b·ªã c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ nh·∫≠n gi·ªçng n√≥i.");
      return;
    }
    const recognition = new SpeechRecognition();
    recognition.lang = "en-US";
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    recordBtn.onclick = () => {
      speechResultDiv.textContent = "üéôÔ∏è ƒêang nghe...";
      recognition.start();
    };

    recognition.onresult = (event) => {
      if (recognition) recognition.stop(); // d·ª´ng ngay khi c√≥ k·∫øt qu·∫£
      const transcript = event.results[0][0].transcript.toLowerCase().trim();
      checkAccuracy(transcript, myQuestions[data.turnIndex]);

    };

    recognition.onerror = (event) => {
      speechResultDiv.innerText = `‚ùå L·ªói: ${event.error}`;
    };
  } else {
    stopTurnTimer();
  }


  // Game area visibility
  gameArea.style.display = (data.player1 || data.player2) ? "block" : "none";
}

if (recognition) {
  recognition.onresult = (event) => {
    if (recognition) recognition.stop(); // ‚õî D·ª´ng ghi √¢m ngay khi c√≥ k·∫øt qu·∫£
    const transcript = event.results[0][0].transcript.toLowerCase().trim();
    const myQuestions = (playerName === data.player1) ? questionsP1 : questionsP2;
    const refText = myQuestions[data.turnIndex]; // c√¢u hi·ªán t·∫°i
    checkAccuracy(transcript, refText);


  };


  recognition.onerror = (event) => {
    speechResultDiv.innerText = `‚ùå L·ªói: ${event.error}`;
  };
}

recordBtn.addEventListener("click", () => {
  if (!recognition) {
    alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ghi √¢m.");
    return;
  }
  speechResultDiv.textContent = "üéôÔ∏è ƒêang nghe...";
  recognition.start();
});


async function tryJoinFirstAvailableRoom(level) {
  // scan room-1..room-30; prefer occupy player1 if empty, else player2 if empty
  for (let i = 1; i <= 30; i++) {
    const roomId = `room-${i}`;
    const ref = await ensureRoomExists(level, roomId);
    const snap = await getDoc(ref);
    const data = snap.data();

    // If I'm already in this room (browser rejoin), attach listener and return
    if (data.player1 === playerName || data.player2 === playerName) {
      await attachRoom(level, roomId);
      return { level, roomId };
    }

    // Take slot
    if (!data.player1) {
      await updateDoc(ref, {
        player1: playerName,
        currentTurn: null,
        started: false,
        turnIndex: 0,
        lastUpdated: Date.now()
      });
      await attachRoom(level, roomId);
      return { level, roomId };
    }
    if (!data.player2 && data.player1 !== playerName) {
      await updateDoc(ref, {
        player2: playerName,
        // start match now that 2 players exist
        started: true,
        currentTurn: data.currentTurn || data.player1, // player1 starts
        turnIndex: data.turnIndex || 0,
        lastUpdated: Date.now()
      });
      await attachRoom(level, roomId);
      return { level, roomId };
    }
  }
  throw new Error("Kh√¥ng c√≤n ph√≤ng tr·ªëng trong tr√¨nh ƒë·ªô n√†y.");
}

async function attachRoom(level, roomId) {
  // cleanup previous listener
  if (unsubRoom) {
    unsubRoom();
    unsubRoom = null;
  }
  currentLevel = String(level);
  currentRoomId = roomId;

  roomIdSpan.textContent = currentRoomId;
  roomLevelSpan.textContent = currentLevel;
  

  const ref = roomDocRef(level, roomId);
  unsubRoom = onSnapshot(ref, (snap) => {
    if (!snap.exists()) return;
    const data = snap.data();
    renderRoom(data);

    // Status message
    if (!data.player2) {
      statusDiv.textContent = "ƒêang ch·ªù ƒë·ªëi th·ªß...";
    } else if (data.started) {
      statusDiv.textContent = "Tr·∫≠n ƒë·∫•u ƒë√£ b·∫Øt ƒë·∫ßu!";
    } else {
      statusDiv.textContent = "ƒê·ªëi th·ªß ƒë√£ r·ªùi. Ch·ªù ng∆∞·ªùi m·ªõi...";
    }
  });
}

// Actions
joinBtn.addEventListener("click", async () => {
  try {
    const level = levelSelect.value;
    if (currentRoomId) {
      alert("B·∫°n ƒë√£ ·ªü trong ph√≤ng. H√£y tho√°t tr∆∞·ªõc khi tham gia ph√≤ng kh√°c.");
      return;
    }
    statusDiv.textContent = "ƒêang t√¨m ph√≤ng tr·ªëng...";
    const { roomId } = await tryJoinFirstAvailableRoom(level);
    statusDiv.textContent = `ƒê√£ tham gia ph√≤ng ${roomId}.`;
  } catch (e) {
    console.error(e);
    statusDiv.textContent = e.message || "L·ªói tham gia ph√≤ng.";
    alert(e.message || "L·ªói tham gia ph√≤ng.");
  }
});



async function completeTurn() {
  if (!currentLevel || !currentRoomId) return;
  const ref = roomDocRef(currentLevel, currentRoomId);
  const snap = await getDoc(ref);
  if (!snap.exists()) return;
  const data = snap.data();

  const nextIndex = data.turnIndex + 1;
  const myQuestions = (playerName === data.player1) ? questionsP1 : questionsP2;
  if (nextIndex >= myQuestions.length) {

    if (recognition) recognition.stop(); // ‚õî D·ª´ng ghi √¢m khi tr·∫≠n k·∫øt th√∫c

    stopTurnTimer();
    statusDiv.textContent = "üéâ Tr·∫≠n ƒë·∫•u k·∫øt th√∫c!";
    setTimeout(async () => {
      await updateDoc(ref, {
        player1: null,
        player2: null,
        currentTurn: null,
        turnIndex: 0,
        started: false,
        lastUpdated: Date.now()
      });
      if (unsubRoom) { unsubRoom(); unsubRoom = null; }
      currentLevel = null;
      currentRoomId = null;
      gameArea.style.display = "none";
      statusDiv.textContent = "Ch·ªçn tr√¨nh ƒë·ªô ƒë·ªÉ b·∫Øt ƒë·∫ßu tr·∫≠n m·ªõi.";
    }, 5000);
    return;
  }

  const nextTurn = (data.currentTurn === data.player1) ? data.player2 : data.player1;
  await updateDoc(ref, {
    turnIndex: nextIndex,
    currentTurn: nextTurn,
    lastUpdated: Date.now()
  });
}


// Cleanup when leaving
async function leaveRoom() {
  if (recognition) recognition.stop(); // ‚õî D·ª´ng ghi √¢m khi tho√°t ph√≤ng
  stopTurnTimer(); // ‚õî D·ª´ng h·∫πn gi·ªù l∆∞·ª£t n·∫øu ƒëang ch·∫°y
  if (!currentLevel || !currentRoomId) return;
  const ref = roomDocRef(currentLevel, currentRoomId);
  const snap = await getDoc(ref);
  if (snap.exists()) {
    const data = snap.data();
    const updates = { lastUpdated: Date.now() };

    if (data.player1 === playerName) {
      updates.player1 = null;
    } else if (data.player2 === playerName) {
      updates.player2 = null;
    }

    // If someone leaves, stop the match
    updates.started = false;
    updates.currentTurn = null;

    // If room becomes empty ‚Üí reset cleanly
    // N·∫øu m√¨nh l√† ng∆∞·ªùi cu·ªëi c√πng r·ªùi ph√≤ng ‚Üí xo√° h·∫≥n document
    if ((data.player1 === playerName && !data.player2) ||
        (data.player2 === playerName && !data.player1)) {
      await deleteDoc(ref);
    } else {
      await updateDoc(ref, updates);
    }

  }

  // Unsubscribe and reset UI state
  if (unsubRoom) { unsubRoom(); unsubRoom = null; }
  currentLevel = null;
  currentRoomId = null;
  roomIdSpan.textContent = "‚Äî";
  roomLevelSpan.textContent = "‚Äî";
  p1Span.textContent = "‚Äî"; p1Span.className = "badge";
  p2Span.textContent = "‚Äî"; p2Span.className = "badge";
  currentTurnSpan.textContent = "‚Äî";
  questionText.textContent = "‚Äî";
  turnIndexSpan.textContent = "0";
  
  gameArea.style.display = "none";
  statusDiv.textContent = "ƒê√£ tho√°t ph√≤ng.";
}

// Auto cleanup on tab close
window.addEventListener("beforeunload", async (e) => {
  // Best-effort cleanup; may not always complete due to browser timing
  try { await leaveRoom(); } catch {}
});
