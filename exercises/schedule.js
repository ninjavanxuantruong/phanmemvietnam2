// ‚úÖ URL Google Sheet
const SCHEDULE_URL = "https://docs.google.com/spreadsheets/d/1xdGIaXekYFQqm1K6ZZyX5pcrmrmjFdSgTJeW27yZJmQ/gviz/tq?tqx=out:json";
const VOCAB_URL = "https://docs.google.com/spreadsheets/d/1KaYYyvkjFxVVobRHNs9tDxW7S79-c5Q4mWEKch6oqks/gviz/tq?tqx=out:json";


// ‚úÖ Bi·∫øn to√†n c·ª•c
let wordBank = [];
let suggestedUnitRaw = "";
let normalizedUnitCode = "";

const spacedConfig = {
  "2": [4, 11, 25],
  "3": [4, 11, 25],
  "4": [4, 11, 25],
  "5": [4, 11, 25],
  "6": [4, 11, 25]
};

// ‚úÖ Chu·∫©n h√≥a m√£ b√†i
function normalizeUnit(str) {
  if (!str || typeof str !== "string") return "";
  return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^0-9]/g, "").trim();
}

function extractCodeFromTitle(title) {
  if (!title || typeof title !== "string") return "";

  // T√°ch theo d·∫•u c√°ch ho·∫∑c d·∫•u g·∫°ch
  const parts = title.trim().split(/[-\s.]+/);

  // Ki·ªÉm tra ƒë√∫ng ƒë·ªãnh d·∫°ng: 1 s·ªë - 2 s·ªë - 1 s·ªë
  if (parts.length >= 3 && /^\d+$/.test(parts[0]) && /^\d+$/.test(parts[1]) && /^\d+$/.test(parts[2])) {
    return parts[0] + parts[1] + parts[2]; // V√≠ d·ª•: "4" + "04" + "1" ‚Üí "4041"
  }

  return ""; // Kh√¥ng kh·ªõp ƒë·ªãnh d·∫°ng
}


async function resolveTitlesFromSheet2(codeList) {
  const res = await fetch(VOCAB_URL);
  const text = await res.text();
  const json = JSON.parse(text.substring(47).slice(0, -2));
  const rows = json.table.rows;

  const titleMap = {};

  for (let row of rows) {
    const rawTitle = row.c[1]?.v?.toString().trim(); // c·ªôt B: ti√™u ƒë·ªÅ b√†i h·ªçc
    if (!rawTitle) continue;

    const code = extractCodeFromTitle(rawTitle); // ‚úÖ t√°ch ƒë√∫ng m√£ b√†i t·ª´ ti√™u ƒë·ªÅ
    if (codeList.includes(code)) {
      titleMap[code] = rawTitle; // ‚úÖ gi·ªØ nguy√™n ti√™u ƒë·ªÅ g·ªëc
    }
  }

  return titleMap;
}



// ‚úÖ Chuy·ªÉn ng√†y d·∫°ng "dd/mm/yyyy" ‚Üí "yyyy-mm-dd"
function convertSheetDateToISO(dateStr) {
  if (!dateStr || typeof dateStr !== "string") return "";
  const parts = dateStr.split("/").map(p => p.trim());
  if (parts.length !== 3) return "";

  let [dd, mm, yyyy] = parts;
  if (dd.length === 1) dd = "0" + dd;
  if (mm.length === 1) mm = "0" + mm;

  const isoStr = `${yyyy}-${mm}-${dd}`;
  const testDate = new Date(isoStr);
  if (isNaN(testDate.getTime())) {
    console.warn("‚ö†Ô∏è Ng√†y kh√¥ng h·ª£p l·ªá:", dateStr);
    return "";
  }

  return isoStr;
}

// ‚úÖ X√°o tr·ªôn m·∫£ng (Fisher‚ÄìYates shuffle)
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}


// ‚úÖ H√†m th√™m b√†i v√†o l·ªãch v·ªõi logic ∆∞u ti√™n
function addLesson(schedule, iso, entry) {
  const priority = { new: 1, review: 2, related: 3, old: 4 };

  if (!schedule[iso]) {
    schedule[iso] = entry;
    return;
  }

  const existing = schedule[iso];

  if (priority[entry.type] < priority[existing.type]) {
    // entry quan tr·ªçng h∆°n ‚Üí ƒë·∫©y b√†i c≈© xu·ªëng
    let nextDate = new Date(iso);
    nextDate.setDate(nextDate.getDate() + 1);
    addLesson(schedule, nextDate.toISOString().split("T")[0], existing);
    schedule[iso] = entry;
  } else {
    // entry k√©m ∆∞u ti√™n h∆°n ‚Üí ƒë·∫©y entry xu·ªëng
    let nextDate = new Date(iso);
    nextDate.setDate(nextDate.getDate() + 1);
    addLesson(schedule, nextDate.toISOString().split("T")[0], entry);
  }
}


// ‚úÖ T·∫°o l·ªãch h·ªçc t·ª´ ng√†y g·ªëc
function generateLessonSchedule(mainCode, relatedCodes, baseDateStr, reviewOffsets) {
  const baseDate = new Date(baseDateStr);
  const schedule = [];
  const usedDates = new Map(); // date ‚Üí s·ªë l∆∞·ª£ng b√†i ƒë√£ g√°n
  const newLessonDates = new Set(); // ‚úÖ ng√†y ƒë√£ c√≥ b√†i m·ªõi

  // ‚úÖ G√°n b√†i m·ªõi v√†o ng√†y g·ªëc ‚Äî lu√¥n ƒë·ª©ng m·ªôt m√¨nh
  const baseISO = baseDate.toISOString().split("T")[0];
  schedule.push({ date: baseISO, code: mainCode, type: "new", relatedTo: mainCode });
  usedDates.set(baseISO, 1);
  newLessonDates.add(baseISO); // ‚úÖ ƒë√°nh d·∫•u ng√†y c√≥ b√†i m·ªõi

  // ‚úÖ G√°n b√†i √¥n t·∫≠p v√†o c√°c ng√†y offset
  for (let offset of reviewOffsets) {
    const d = new Date(baseDate);
    d.setDate(d.getDate() + offset);
    let iso = d.toISOString().split("T")[0];

    // ‚úÖ N·∫øu ng√†y c√≥ b√†i m·ªõi ho·∫∑c ƒë√£ ƒë·ªß 2 b√†i ‚Üí l√πi
    while (newLessonDates.has(iso) || (usedDates.get(iso) || 0) >= 2) {
      d.setDate(d.getDate() + 1);
      iso = d.toISOString().split("T")[0];
    }

    schedule.push({ date: iso, code: mainCode, type: "review", relatedTo: mainCode });
    usedDates.set(iso, (usedDates.get(iso) || 0) + 1);
  }

  // ‚úÖ G√°n b√†i li√™n quan v√†o c√°c ng√†y ti·∫øp theo
  let relatedIndex = 0;
  let nextDate = new Date(baseDate);
  while (relatedIndex < relatedCodes.length) {
    nextDate.setDate(nextDate.getDate() + 1);
    let iso = nextDate.toISOString().split("T")[0];

    // ‚úÖ N·∫øu ng√†y c√≥ b√†i m·ªõi ho·∫∑c ƒë√£ ƒë·ªß 2 b√†i ‚Üí l√πi
    while (newLessonDates.has(iso) || (usedDates.get(iso) || 0) >= 2) {
      nextDate.setDate(nextDate.getDate() + 1);
      iso = nextDate.toISOString().split("T")[0];
    }

    schedule.push({ date: iso, code: relatedCodes[relatedIndex], type: "related", relatedTo: mainCode });
    usedDates.set(iso, (usedDates.get(iso) || 0) + 1);
    relatedIndex++;
  }

  console.log(`üìÖ L·ªãch h·ªçc t·∫°o t·ª´ ng√†y ${baseDateStr} cho b√†i ${mainCode}:`, schedule);
  return schedule;
}

function buildFullScheduleFromLessons(lessonList, reviewOffsets) {
  const schedule = {};

  // B∆∞·ªõc 1: G√°n b√†i m·ªõi
  for (let lesson of lessonList) {
    const iso = lesson.baseDate;
    if (!iso) continue;

    addLesson(schedule, iso, {
      code: lesson.code,
      title: lesson.title,
      type: "new",
      relatedTo: lesson.code
    });
  }

  // B∆∞·ªõc 2: G√°n b√†i √¥n t·∫≠p
  for (let lesson of lessonList) {
    for (let offset of reviewOffsets) {
      const d = new Date(lesson.baseDate);
      d.setDate(d.getDate() + offset);
      const iso = d.toISOString().split("T")[0];

      addLesson(schedule, iso, {
        code: lesson.code,
        title: lesson.code,
        type: "review",
        relatedTo: lesson.code
      });
    }
  }

  // B∆∞·ªõc 3: G√°n b√†i li√™n quan
  for (let lesson of lessonList) {
    let d = new Date(lesson.baseDate);
    d.setDate(d.getDate() + 1);

    for (let relatedCode of lesson.relatedCodes || []) {
      const iso = d.toISOString().split("T")[0];

      addLesson(schedule, iso, {
        code: relatedCode,
        title: relatedCode,
        type: "related",
        relatedTo: lesson.code
      });

      d.setDate(d.getDate() + 1);
    }
  }

  console.log("üìÖ L·ªãch h·ªçc ƒë√£ x√¢y d·ª±ng:", schedule);
  return schedule;
}



// ‚úÖ T·∫°o l·∫°i to√†n b·ªô l·ªãch h·ªçc t·ª´ Sheet theo l·ªõp
async function generateFullScheduleFromSheet(className) {
  try {
    const res = await fetch(SCHEDULE_URL);
    const text = await res.text();
    const json = JSON.parse(text.substring(47).slice(0, -2));
    const rows = json.table.rows;

    const lessonList = [];

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!row || !row.c || !row.c[0] || !row.c[1] || !row.c[2]) continue;

      const sheetClass = row.c[0].v.toString().trim().toLowerCase();
      if (!sheetClass.includes(className)) continue;

      const mainRaw = row.c[2].v.toString().trim();
      const relatedRaw = row.c[3]?.v?.toString().trim() || "";

      const mainCode = normalizeUnit(mainRaw);
      const relatedCodes = relatedRaw
        ? relatedRaw.split(",").map(code => normalizeUnit(code.trim())).filter(Boolean)
        : [];

      const rawDate = row.c[1].v.toString().trim();
      const baseDate = convertSheetDateToISO(rawDate);

      lessonList.push({
        code: mainCode,
        title: mainRaw,
        relatedCodes,
        baseDate
      });
    }

    const reviewOffsets = spacedConfig[className] || [4, 11, 25];
    const fullSchedule = buildFullScheduleFromLessons(lessonList, reviewOffsets);

    // T√≠nh ng√†y xa nh·∫•t c√≥ th·ªÉ (KH√îNG l∆∞u v√†o l·ªãch)
    const lastLesson = lessonList[lessonList.length - 1];
    let maxDate = new Date(lastLesson.baseDate);
    const maxOffset = Math.max(...reviewOffsets);
    maxDate.setDate(maxDate.getDate() + maxOffset);
    if (lastLesson.relatedCodes && lastLesson.relatedCodes.length > 0) {
      maxDate.setDate(maxDate.getDate() + lastLesson.relatedCodes.length);
    }
    const maxDateISO = maxDate.toISOString().split("T")[0];

    // Ghi l·ªãch m·ªõi
    const docRef = window.doc(window.db, "lich", className);
    await window.setDoc(docRef, fullSchedule);
    console.log("‚úÖ ƒê√£ ghi to√†n b·ªô l·ªãch m·ªõi v√†o Firebase cho l·ªõp:", className);

    // B·ªï sung b√†i c≈© d√πng maxDate t√≠nh s·∫µn (kh√¥ng c·∫ßn _maxDate trong doc)
    await autoFillOldLessons(className, fullSchedule, maxDateISO);

    // Hi·ªÉn th·ªã
    renderFullScheduleFromFirebase(className);
    showTodayLessonFromFirebase(className);
  } catch (err) {
    console.error("‚ùå L·ªói khi t·∫°o l·∫°i l·ªãch h·ªçc:", err.message);
  }
}



async function autoFillOldLessons(className, currentSchedule) {
  console.log("üìå B·∫Øt ƒë·∫ßu b·ªï sung b√†i c≈© cho l·ªõp:", className);

  const todayISO = new Date().toISOString().split("T")[0];
  const bosungRef = window.doc(window.db, "bosung", className);

  // ‚úÖ L·∫•y d·ªØ li·ªáu b·ªï sung c≈© t·ª´ Firebase
  const bosungSnap = await window.getDoc(bosungRef);
  const oldBosung = bosungSnap.exists() ? bosungSnap.data() : {};

  // ‚úÖ Gi·ªØ l·∫°i c√°c ng√†y tr∆∞·ªõc h√¥m nay
  const preserved = {};
  for (let date in oldBosung) {
    if (date < todayISO) {
      preserved[date] = oldBosung[date];
    }
  }

  // ‚úÖ Lo·∫°i tr·ª´ t·∫•t c·∫£ m√£ b√†i ƒë√£ c√≥ trong l·ªãch
  const usedCodes = Object.values(currentSchedule).map(item => normalizeUnit(item.code));

  // ‚úÖ Lo·∫°i tr·ª´ th√™m c√°c b√†i b·ªï sung tr∆∞·ªõc h√¥m nay
  const preservedCodes = Object.values(preserved).map(item => normalizeUnit(item.code));

  // ‚úÖ T√¨m b√†i c≈© t·ª´ Sheet 2
  const res = await fetch(VOCAB_URL);
  const text = await res.text();
  const json = JSON.parse(text.substring(47).slice(0, -2));
  const rows = json.table.rows;

  const allUnits = rows.map(row => {
    const raw = row.c[1]?.v?.toString().trim();
    return extractCodeFromTitle(raw);
  }).filter(Boolean);

  const newCodes = Object.values(currentSchedule)
    .filter(item => item.type === "new")
    .map(item => normalizeUnit(item.code));

  const highestCode = newCodes.sort().reverse()[0];
  const sortedOldUnits = allUnits.filter(code => code < highestCode);

  // ‚úÖ T√¨m c√°c ng√†y tr·ªëng t·ª´ h√¥m nay tr·ªü ƒëi
  let maxDate;
  if (currentSchedule._maxDate) {
    maxDate = new Date(currentSchedule._maxDate);
  } else {
    const allDates = Object.keys(currentSchedule).sort((a, b) => new Date(a) - new Date(b));
    maxDate = new Date(allDates[allDates.length - 1]);
  }


  const emptyDates = [];
  const d = new Date(todayISO);
  while (d <= maxDate) {
    const iso = d.toISOString().split("T")[0];
    if (!currentSchedule[iso]) emptyDates.push(iso);
    d.setDate(d.getDate() + 1);
  }

  console.log("üìÖ Ng√†y tr·ªëng c·∫ßn b·ªï sung:", emptyDates);

  // ‚úÖ Lo·∫°i tr·ª´ b√†i ƒë√£ h·ªçc v√† b√†i t·ª´ng b·ªï sung tr∆∞·ªõc h√¥m nay
  let excluded = new Set([...usedCodes, ...preservedCodes]);
  let finalUnits = [...new Set(sortedOldUnits.filter(code => !excluded.has(code)))];

  // ‚úÖ Random danh s√°ch b√†i c√≤n l·∫°i
  finalUnits = shuffleArray(finalUnits);

  // ‚úÖ N·∫øu kh√¥ng ƒë·ªß b√†i ƒë·ªÉ g√°n ‚Üí cho ph√©p d√πng l·∫°i b√†i ƒë√£ t·ª´ng b·ªï sung
  const totalNeeded = emptyDates.length;
  if (finalUnits.length < totalNeeded) {
    console.warn("‚ö†Ô∏è Kh√¥ng ƒë·ªß b√†i m·ªõi ƒë·ªÉ b·ªï sung, cho ph√©p d√πng l·∫°i b√†i ƒë√£ t·ª´ng b·ªï sung tr∆∞·ªõc h√¥m nay");
    excluded = new Set(usedCodes); // b·ªè preservedCodes ra kh·ªèi excluded
    finalUnits = [...new Set(sortedOldUnits.filter(code => !excluded.has(code)))];
    finalUnits = shuffleArray(finalUnits); // random l·∫°i
  }

  // ‚úÖ Tra title t·ª´ Sheet 2
  const titleMap = {};
  for (let row of rows) {
    const rawTitle = row.c[1]?.v?.toString().trim();
    const code = extractCodeFromTitle(rawTitle);
    if (finalUnits.includes(code)) {
      titleMap[code] = rawTitle;
    }
  }

  // ‚úÖ G√°n b√†i b·ªï sung v√†o l·ªãch v√† bosung m·ªõi ‚Äî m·ªói ng√†y 1 b√†i
  const bosungSchedule = {};
  let unitIndex = 0;

  for (let date of emptyDates) {
    if (unitIndex >= finalUnits.length) unitIndex = 0; // quay v√≤ng n·∫øu h·∫øt b√†i

    const code = finalUnits[unitIndex];
    const entry = {
      code,
      title: titleMap[code] || code,
      type: "old",
      relatedTo: ""
    };

    addLesson(currentSchedule, date, entry); // d√πng addLesson ƒë·ªÉ tr√°nh xung ƒë·ªôt
    bosungSchedule[date] = entry;

    console.log(`üìÖ G√°n b√†i b·ªï sung ${code} v√†o ng√†y ${date}`);
    unitIndex++;
  }

  // ‚úÖ Ghi l·ªãch m·ªõi v√†o Firebase
  const docRef = window.doc(window.db, "lich", className);
  await window.setDoc(docRef, currentSchedule);

  // ‚úÖ G·ªôp d·ªØ li·ªáu c≈© + m·ªõi ‚Üí ghi v√†o bosung
  const finalBosung = { ...preserved, ...bosungSchedule };
  await window.setDoc(bosungRef, finalBosung);

  console.log("‚úÖ ƒê√£ c·∫≠p nh·∫≠t l·ªãch b·ªï sung:", finalBosung);
}




// ‚úÖ Hi·ªÉn th·ªã b·∫£ng l·ªãch h·ªçc t·ª´ h√¥m nay tr·ªü ƒëi (m·ªói ng√†y 1 b√†i duy nh·∫•t)
async function renderFullScheduleFromFirebase(className) {
  const docRef = window.doc(window.db, "lich", className);

  try {
    const snapshot = await window.getDoc(docRef);
    if (!snapshot.exists()) {
      console.warn("üì≠ Kh√¥ng c√≥ l·ªãch h·ªçc n√†o trong Firebase cho l·ªõp", className);
      return;
    }

    const data = snapshot.data();
    const tableBody = document.querySelector("#scheduleTable tbody");
    tableBody.innerHTML = "";

    // S·∫Øp x·∫øp ng√†y tƒÉng d·∫ßn
    const entries = Object.entries(data)
      .sort(([a], [b]) => new Date(a) - new Date(b));

    let stt = 1;
    for (let [dateStr, lesson] of entries) {
      // lesson l√† object duy nh·∫•t
      const label =
        lesson.type === "new"
          ? "B√†i m·ªõi - Ph·∫£i h·ªçc"
          : lesson.type === "review"
          ? "√în t·∫≠p b√†i m·ªõi - N√™n h·ªçc"
          : lesson.type === "related"
          ? "B√†i li√™n quan b√†i m·ªõi - N√™n h·ªçc"
          : lesson.type === "old"
          ? "B√†i c≈©"
          : lesson.type;

      const row = document.createElement("tr");
      row.innerHTML = `
        <td>${stt++}</td>
        <td>${dateStr}</td>
        <td>${lesson.title}</td>
        <td>${label}</td>
        <td>${lesson.relatedTo || ""}</td>
      `;
      tableBody.appendChild(row);
    }

    console.log("üìã ƒê√£ hi·ªÉn th·ªã l·ªãch h·ªçc t·ª´ h√¥m nay tr·ªü ƒëi cho l·ªõp", className);
  } catch (err) {
    console.error("‚ùå L·ªói khi hi·ªÉn th·ªã b·∫£ng l·ªãch h·ªçc:", err.message);
  }
}

// ‚úÖ Hi·ªÉn th·ªã b·∫£ng l·ªãch h·ªçc t·ª´ h√¥m nay tr·ªü ƒëi
// ‚úÖ Hi·ªÉn th·ªã b·∫£ng l·ªãch h·ªçc t·ª´ h√¥m nay tr·ªü ƒëi (m·ªói ng√†y 1 b√†i duy nh·∫•t)
async function showTodayLessonFromFirebase(className) {
  const todayISO = new Date().toISOString().split("T")[0];
  const docRef = window.doc(window.db, "lich", className);

  try {
    const snapshot = await window.getDoc(docRef);
    if (!snapshot.exists()) return;

    const data = snapshot.data();
    const todayLesson = data[todayISO];
    if (!todayLesson) {
      console.warn("üì≠ Kh√¥ng c√≥ b√†i h·ªçc n√†o h√¥m nay cho l·ªõp", className);
      return;
    }

    renderLessonChecklist(todayLesson);
  } catch (err) {
    console.error("‚ùå L·ªói khi hi·ªÉn th·ªã b√†i h·ªçc h√¥m nay:", err.message);
  }
}



// ‚úÖ Hi·ªÉn th·ªã danh s√°ch b√†i h·ªçc h√¥m nay ƒë·ªÉ ch·ªçn
function renderLessonChecklist(todayLesson) {
  const container = document.getElementById("lessonList");
  container.innerHTML = "";

  const label =
    todayLesson.type === "new"
      ? "B√†i m·ªõi"
      : todayLesson.type === "related"
      ? `Li√™n quan ƒë·∫øn ${todayLesson.relatedTo}`
      : todayLesson.type === "old"
      ? "B√†i c≈©"
      : `√în t·∫≠p c·ªßa ${todayLesson.relatedTo}`;

  const div = document.createElement("div");
  div.innerHTML = `
    <label>
      <input type="checkbox" value="${normalizeUnit(todayLesson.code)}" data-title="${todayLesson.title}" />
      ${todayLesson.title} (${label})
    </label>
  `;
  container.appendChild(div);

  console.log("üìë ƒê√£ hi·ªÉn th·ªã b√†i h·ªçc h√¥m nay:", todayLesson);
  document.getElementById("btnLearnSuggested").disabled = false;
}


// ‚úÖ Hi·ªÉn th·ªã b√†i h·ªçc h√¥m nay t·ª´ Firebase
async function showTodayLessonFromFirebase(className) {
  const todayISO = new Date().toISOString().split("T")[0];
  const docRef = window.doc(window.db, "lich", className);

  try {
    const snapshot = await window.getDoc(docRef);
    if (!snapshot.exists()) return;

    const data = snapshot.data();
    const todayLessons = data[todayISO] || [];
    if (todayLessons.length === 0) {
      console.warn("üì≠ Kh√¥ng c√≥ b√†i h·ªçc n√†o h√¥m nay cho l·ªõp", className);
      return;
    }

    renderLessonChecklist(todayLessons);
  } catch (err) {
    console.error("‚ùå L·ªói khi hi·ªÉn th·ªã b√†i h·ªçc h√¥m nay:", err.message);
  }
}



// ‚úÖ L·∫•y t·ª´ v·ª±ng t·ª´ nhi·ªÅu b√†i
async function fetchVocabularyFromMultipleUnits(unitCodes) {
  try {
    const res = await fetch(VOCAB_URL);
    const text = await res.text();
    const json = JSON.parse(text.substring(47).slice(0, -2));
    const rows = json.table.rows;

    wordBank = [];

    rows.forEach(row => {
      const unitRaw = row.c[1]?.v?.toString().trim();
      const word = row.c[2]?.v?.toString().trim();
      if (unitCodes.includes(normalizeUnit(unitRaw))) {
        wordBank.push(word);
      }
    });

    wordBank = shuffleArray(wordBank);

    if (wordBank.length === 0) {
      alert("Kh√¥ng t√¨m th·∫•y t·ª´ v·ª±ng cho c√°c b√†i ƒë√£ ch·ªçn.");
      return;
    }

    console.log("üì¶ T·ª´ v·ª±ng ƒë√£ l·∫•y:", wordBank);
    localStorage.setItem("wordBank", JSON.stringify(wordBank));
    localStorage.setItem("victoryTotalWords", wordBank.length);
    window.location.href = "exercise.html";
  } catch (err) {
    console.error("‚ùå L·ªói khi l·∫•y t·ª´ v·ª±ng:", err);
  }
}

// ‚úÖ G·∫Øn s·ª± ki·ªán khi trang t·∫£i
document.addEventListener("DOMContentLoaded", () => {
  const classSelect = document.getElementById("classSelect");
  if (classSelect) {
    classSelect.addEventListener("change", () => {
      const className = classSelect.value.trim().toLowerCase();
      if (!className) return;
      console.log("üéØ ƒê√£ ch·ªçn l·ªõp:", className);
      showTodayLessonFromFirebase(className);
      renderFullScheduleFromFirebase(className);
    });
  }

  const btnLearn = document.getElementById("btnLearnSuggested");
  if (btnLearn) {
    btnLearn.addEventListener("click", () => {
      const checked = Array.from(document.querySelectorAll("#lessonList input[type='checkbox']:checked"));
      if (checked.length === 0) {
        alert("B·∫°n ch∆∞a ch·ªçn b√†i n√†o.");
        return;
      }

      const selectedCodes = checked.map(input => input.value);
      const selectedTitles = checked.map(input => input.dataset.title);

      console.log("üéØ ƒê√£ ch·ªçn h·ªçc c√°c b√†i:", selectedTitles);
      fetchVocabularyFromMultipleUnits(selectedCodes);
    });
  }
});
